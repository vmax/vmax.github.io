<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer-when-downgrade">

    <title>Producing long-running reports</title>
    <meta name="description" content="">

    <link rel="stylesheet" href="https://vmax.dev/main.css">

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZHVH8SD2XC"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-ZHVH8SD2XC');
    </script>

    
    
</head>
<body>
    <div class="container">
        <label class="site-title">vmax.dev</label>
        <main id="main" tabindex="-1">
            

<article class="post">
    <a class="baselink" href="https:&#x2F;&#x2F;vmax.dev">&larr;</a>
    <header>
        <h1>Producing long-running reports</h1>
    </header>
    <div class="content">
        <p>Sometimes there's a need to produce reports that take more to produce than
any sensible HTTP load balancer would allow (say, Heroku's 30 seconds limitation).</p>
<p>Usually, we'd overcome it by spawning another machine (<em>worker</em>).
It would handle the long-running tasks we hand off to it and won't be subject to
HTTP request-response cycle time limitations.</p>
<p>While being a generally preferred approach, I don't necessarily enjoy it.
It comes with its share of complexities, such as having more components to keep track of:
worker, message broker, result broker and storage for the produced reports.</p>
<p>An alternative approach I suggest would be to <strong>stream</strong> the response bits as they are being produced.
Then limitations become much more manageable: you have to send the first byte before 30 seconds,
each next chunk has 55 seconds to be produced (<a href="https://devcenter.heroku.com/articles/http-routing#timeouts">source</a>)</p>
<p>Here is how you would implement it with Django:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">import </span><span>csv
</span><span style="color:#b48ead;">import </span><span>time
</span><span style="color:#b48ead;">import </span><span>io
</span><span style="color:#b48ead;">from </span><span>django.http </span><span style="color:#b48ead;">import </span><span>StreamingHttpResponse
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">streaming_csv_view</span><span>(</span><span style="color:#bf616a;">request</span><span>):
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">data</span><span>():
</span><span>        </span><span style="color:#b48ead;">for </span><span>i </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">30</span><span>):
</span><span>            </span><span style="color:#b48ead;">yield f</span><span>&quot;</span><span style="color:#a3be8c;">Row </span><span>{i}</span><span style="color:#96b5b4;">\n</span><span>&quot;  </span><span style="color:#65737e;"># yield results as they are produced
</span><span>            time.</span><span style="color:#bf616a;">sleep</span><span>(</span><span style="color:#d08770;">2</span><span>)  </span><span style="color:#65737e;"># simulate non-instant generation
</span><span>    response = </span><span style="color:#bf616a;">StreamingHttpResponse</span><span>(</span><span style="color:#bf616a;">data</span><span>(), </span><span style="color:#bf616a;">content_type</span><span>=&quot;</span><span style="color:#a3be8c;">text/csv</span><span>&quot;)
</span><span>    response[&#39;</span><span style="color:#a3be8c;">Content-Disposition</span><span>&#39;] = &#39;</span><span style="color:#a3be8c;">attachment; filename=&quot;report.csv&quot;</span><span>&#39;
</span><span>    </span><span style="color:#b48ead;">return </span><span>response
</span></code></pre>
<p>Note that if you're using GUnicorn as your server, you'd need to switch to asynchronous workers (
if you were using <code>sync</code> workers before):</br>
<code>gunicorn django_app.wsgi -k gevent</code></p>

    </div>

    
    <div class="article-info">
        
        <div class="article-date">2021-01-03</div>
        
    </div>

</article>

<script src="https://utteranc.es/client.js"
        repo="vmax/vmax.github.io"
        issue-term="url"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>


        </main>
    </div>
</body>
</html>
